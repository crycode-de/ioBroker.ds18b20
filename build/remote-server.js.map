{
  "version": 3,
  "sources": ["../src/remote-server.ts"],
  "sourcesContent": ["/**\n * Server for remote connections.\n */\n\nimport { EventEmitter } from 'events';\n\nimport {\n  createServer,\n  Server,\n  Socket,\n} from 'net';\n\nimport { boundMethod } from 'autobind-decorator';\n\nimport type { Ds18b20Adapter } from './main';\nimport {\n  decrypt,\n  encrypt,\n  REMOTE_PROTOCOL_VERSION,\n} from './remote/common';\n\n/**\n * Information about a connected client.\n */\ninterface RemoteClient {\n  socket: Socket;\n  systemId: string;\n}\n\n/**\n * Interface to declare events for the RemoteSensorServer class.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface RemoteSensorServer {\n  on (event: 'listening', listener: () => void): this;\n  on (event: 'error', listener: (err: Error) => void): this;\n  on (event: 'sensorData', listener: (data: RemoteDataRead) => void): this;\n  on (event: 'searchData', listener: (data: RemoteDataSearch) => void): this;\n  on (event: 'remotesChanged', listener: (remotes: string[]) => void): this;\n\n  emit (event: 'listening'): boolean;\n  emit (event: 'error', err: Error): boolean;\n  emit (event: 'sensorData', data: RemoteDataRead): boolean;\n  emit (event: 'searchData', data: RemoteDataSearch): boolean;\n  emit (event: 'remotesChanged', data: string[]): boolean;\n}\n\n/**\n * Server for remote connections.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class RemoteSensorServer extends EventEmitter {\n\n  /**\n   * Instance of the adapter.\n   */\n  private adapter: Ds18b20Adapter;\n\n  /**\n   * Buffer containing the 32 bit encryption key.\n   */\n  private encryptionKey: Buffer;\n\n  /**\n   * Instance of the tcp server to handle socket connections.\n   */\n  private server: Server;\n\n  /**\n   * Connected sockets.\n   */\n  private sockets: Record<string, RemoteClient> = {};\n\n  /**\n   * Timeouts for sockets.\n   * Used to disconnect a socket after idle before it is identified.\n   */\n  private socketTimeouts: Record<string, ioBroker.Timeout> = {};\n\n  constructor (port: number, encKey: string, adapter: Ds18b20Adapter) {\n    super();\n\n    this.adapter = adapter;\n\n    this.encryptionKey = Buffer.from(encKey, 'hex');\n\n    this.server = createServer();\n\n    this.server.on('connection', this.handleConnection);\n\n    this.server.on('error', (err: Error) => {\n      this.emit('error', err);\n    });\n\n    this.server.listen(port, () => {\n      this.emit('listening');\n    });\n  }\n\n  /**\n   * Returns if the server is listening for connections.\n   */\n  public isListening (): boolean {\n    return this.server.listening;\n  }\n\n  /**\n   * Returns an array of the system IDs of all currently connected remote systems.\n   */\n  public getConnectedSystems (): string[] {\n    const systems: string[] = [];\n    for (const socketId in this.sockets) {\n      systems.push(this.sockets[socketId].systemId);\n    }\n    return systems;\n  }\n\n  /**\n   * Read from a remote sensor.\n   * @param clientSystemId The system ID of the remote client to send the request to.\n   * @param sensorAddress The sensor address.\n   */\n  public async read (clientSystemId: string, sensorAddress: string): Promise<string> {\n    // get the socket\n    let client: RemoteClient | null = null;\n    for (const socketId in this.sockets) {\n      if (this.sockets[socketId].systemId === clientSystemId) {\n        client = this.sockets[socketId];\n        break;\n      }\n    }\n\n    if (!client) {\n      // client not connected\n      throw new Error(`Remote system ${clientSystemId} is not connected.`);\n    }\n\n    // timestamp for the request, used to identify response\n    const requestTs = Date.now();\n\n    // prepare promise to wait for feedback with a timeout of 5 seconds\n    const prom = new Promise<string>((resolve, reject) => {\n      let timeout: ioBroker.Timeout | null = null;\n\n      const handler = (data: RemoteDataRead): void => {\n        if (typeof data !== 'object' || data.address !== sensorAddress || data.ts !== requestTs) return;\n        if (timeout) {\n          this.adapter.clearTimeout(timeout);\n        }\n        this.removeListener('sensorData', handler);\n        resolve(data.raw || '');\n      };\n\n      timeout = this.adapter.setTimeout(() => {\n        this.removeListener('sensorData', handler);\n        reject(new Error(`No response from remote system ${clientSystemId}`));\n      }, 5000);\n\n      this.on('sensorData', handler);\n    });\n\n    // send the request (async but don't wait)\n    this.send(client.socket, {\n      cmd: 'read',\n      ts: requestTs,\n      address: sensorAddress,\n    })\n      .catch((err) => {\n        this.adapter.log.error(`Error while sending request to remote system ${clientSystemId}: ${err}`);\n      });\n\n    // wait for the feedback promise to resolve\n    const raw = await prom;\n\n    return raw;\n  }\n\n  /**\n   * Search for sensors an all currently connected remote systems.\n   */\n  public async search (): Promise<SearchedSensor[]> {\n    const sensors: SearchedSensor[] = [];\n\n    // array of promises for parallel search on all remote systems\n    const proms: Promise<SearchedSensor[]>[] = [];\n\n    for (const socketId in this.sockets) {\n      const client = this.sockets[socketId];\n\n      // timestamp for the request, used to identify response\n      const requestTs = Date.now();\n\n      // send the request (async but don't wait)\n      this.send(client.socket, {\n        cmd: 'search',\n        ts: requestTs,\n        systemId: client.systemId,\n      })\n        .catch((err) => {\n          this.adapter.log.error(`Error while sending request to remote system ${client.systemId}: ${err}`);\n        });\n\n      // wait for feedback with a timeout of 5 seconds\n      proms.push(new Promise<SearchedSensor[]>((resolve, reject) => {\n        let timeout: ioBroker.Timeout | null = null;\n\n        const handler = (data: RemoteDataSearch): void => {\n          if (typeof data !== 'object' || data.systemId !== client.systemId || data.ts !== requestTs) return;\n          if (timeout) {\n            this.adapter.clearTimeout(timeout);\n          }\n          this.removeListener('sensorData', handler);\n          if (!Array.isArray(data.addresses)) {\n            data.addresses = [];\n          }\n          resolve(data.addresses.map((a) => ({ address: a, remoteSystemId: client.systemId })));\n        };\n\n        timeout = this.adapter.setTimeout(() => {\n          this.removeListener('sensorData', handler);\n          reject(new Error(`No response from remote system ${client.systemId}`));\n        }, 5000);\n\n        this.on('searchData', handler);\n      }));\n    }\n\n    const results = await Promise.all(proms);\n    results.forEach((r) => sensors.push(...r));\n\n    return sensors;\n  }\n\n  /**\n   * Stop the server and close all socket connections.\n   */\n  public stop (): Promise<void> {\n    return new Promise<void>((resolve) => {\n      this.server.close(() => resolve());\n    });\n  }\n\n  /**\n   * Handler for new socket connections.\n   * @param socket The connected socket.\n   */\n  @boundMethod\n  private handleConnection (socket: Socket): void {\n    const socketId = `${socket.remoteAddress}:${socket.remotePort}`;\n    this.adapter.log.debug(`socket connect ${socketId}`);\n\n    socket.on('close', () => {\n      this.adapter.log.debug(`socket closed ${socketId}`);\n      if (this.sockets[socketId]) {\n        this.adapter.log.info(`Remote system ${this.sockets[socketId].systemId} (${socketId}) disconnected`);\n      } else {\n        this.adapter.log.info(`Remote system ${socketId} disconnected`);\n      }\n\n      if (this.socketTimeouts[socketId]) {\n        this.adapter.clearTimeout(this.socketTimeouts[socketId]);\n        delete this.socketTimeouts[socketId];\n      }\n\n      delete this.sockets[socketId];\n\n      this.emit('remotesChanged', this.getConnectedSystems());\n    });\n\n    // collect all incoming data and split it by `\\n`\n    let dataStr = '';\n    socket.on('data', (data: Buffer) => {\n      dataStr += data.toString();\n\n      // dataStr may contain multiple `\\n`!\n      let idx = dataStr.indexOf('\\n');\n      while (idx > 0) {\n        const raw = dataStr.slice(0, idx);\n        dataStr = dataStr.slice(idx+1);\n        this.handleSocketData(socketId, socket, raw);\n        idx = dataStr.indexOf('\\n');\n      }\n    });\n\n    // set timeout to close unknown sockets after 5 seconds\n    this.socketTimeouts[socketId] = this.adapter.setTimeout(() => {\n      this.adapter.log.warn(`Disconnecting remote ${socketId} due to inactivity before identification`);\n      socket.destroy();\n      delete this.socketTimeouts[socketId];\n    }, 5000);\n\n    // request client information\n    this.send(socket, { cmd: 'clientInfo', protocolVersion: REMOTE_PROTOCOL_VERSION })\n      .catch((err) => {\n        this.adapter.log.error(`Error while sending request to remote system ${socketId}: ${err}`);\n      });\n  }\n\n  /**\n   * Handler for received encrypted messages from a socket.\n   * @param socketId The ID of the related socket.\n   * @param socket The socket from which the data was received.\n   * @param raw The encrypted received data.\n   */\n  private handleSocketData (socketId: string, socket: Socket, raw: string): void {\n\n    // try to decrypt and parse the data\n    let data: RemoteData;\n    try {\n      const dataStr = decrypt(raw, this.encryptionKey);\n      data = JSON.parse(dataStr);\n    } catch (err: any) {\n      this.adapter.log.warn(`Decrypt of data from ${socketId} failed! ${err.toString()}`);\n      // close the socket\n      socket.destroy();\n      return;\n    }\n\n    this.adapter.log.debug(`data from remote ${socketId}: ${JSON.stringify(data)}`);\n\n    switch (data.cmd) {\n      case 'clientInfo':\n        // got client information\n        if (!data.systemId) {\n          this.adapter.log.warn(`Got invalid data from remote ${socketId}!`);\n          return;\n        }\n\n        // clear the close timeout\n        this.adapter.clearTimeout(this.socketTimeouts[socketId]);\n        delete this.socketTimeouts[socketId];\n\n        // save as known socket\n        this.sockets[socketId] = {\n          socket: socket,\n          systemId: data.systemId,\n        };\n\n        this.adapter.log.info(`Remote system ${data.systemId} connected from ${socket.remoteAddress}`);\n\n        // check the protocol version\n        if (data.protocolVersion !== REMOTE_PROTOCOL_VERSION) {\n          this.adapter.log.warn(`Protocol version ${data.protocolVersion} from remote system ${data.systemId} does not match the adapter protocol version ${REMOTE_PROTOCOL_VERSION}! Please reinstall the remote client.`);\n        }\n\n        this.emit('remotesChanged', this.getConnectedSystems());\n\n        break;\n\n      case 'read':\n        // got sensor data\n        this.emit('sensorData', data);\n        break;\n\n      case 'search':\n        // got search data\n        this.emit('searchData', data);\n        break;\n\n      default:\n        this.adapter.log.warn(`Unknown command from remote system ${socketId}.`);\n    }\n  }\n\n  /**\n   * Send some data to a remote system.\n   * The data will be stringified and encrypted before sending.\n   * @param socket The socket to send the data to.\n   * @param data The data object to send.\n   */\n  private async send (socket: Socket, data: RemoteData): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      socket.write(encrypt(JSON.stringify(data), this.encryptionKey) + '\\n', (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
