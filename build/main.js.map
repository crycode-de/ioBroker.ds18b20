{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/**\n * ioBroker DS18B20 1-wire temperature sensor adapter.\n *\n * (C) 2019-2023 Peter M\u00FCller <peter@crycode.de> (https://github.com/crycode-de/ioBroker.ds18b20)\n */\n\nimport 'source-map-support/register';\n\nimport { readFile, readdir } from 'fs/promises';\n\n\nimport * as crypto from 'crypto';\n\nimport {\n  Adapter,\n  AdapterOptions,\n  EXIT_CODES,\n} from '@iobroker/adapter-core';\n\nimport { boundMethod } from 'autobind-decorator';\n\nimport { Sensor } from './sensor';\n\nimport { RemoteSensorServer } from './remote-server';\nimport { genHexString } from './lib/utils';\nimport { i18n } from './lib/i18n';\n\n/**\n * The ds18b20 adapter.\n */\nclass Ds18b20Adapter extends Adapter {\n\n  /**\n   * Mapping of the ioBroker object IDs to the sensor class instances.\n   */\n  private sensors: Record<string, Sensor> = {};\n\n  /**\n   * The server for remote sensors if enabled.\n   */\n  public remoteSensorServer: RemoteSensorServer | null = null;\n\n  /**\n   * Internal indicator if we are doing a migration from an old version.\n   */\n  private doingMigration: boolean = false;\n\n  /**\n   * Constructor to create a new instance of the adapter.\n   * @param options The adapter options.\n   */\n  public constructor(options: Partial<AdapterOptions> = {}) {\n    super({\n      ...options,\n      name: 'ds18b20',\n    });\n\n    this.on('ready', this.onReady);\n    this.on('stateChange', this.onStateChange);\n    this.on('message', this.onMessage);\n    this.on('unload', this.onUnload);\n  }\n\n  /**\n   * Is called when databases are connected and adapter received configuration.\n   */\n  @boundMethod\n  private async onReady(): Promise<void> {\n    // Reset the connection indicator during startup\n    this.setState('info.connection', false, true);\n\n    // try to get the system language\n    const systemConfig = await this.getForeignObjectAsync('system.config');\n    i18n.language = systemConfig?.common.language || 'en';\n\n    // set default devices path if not defined\n    if (!this.config.w1DevicesPath) {\n      this.config.w1DevicesPath = '/sys/bus/w1/devices';\n    }\n\n    // need to upgrade config from old version (<2.0.0)?\n    if (Object.keys(this.config).includes('_values')) {\n      this.log.info('Migrate config from old version ...');\n      this.doingMigration = true;\n\n      const instanceObj = await this.getForeignObjectAsync(`system.adapter.${this.namespace}`);\n      if (!instanceObj) {\n        this.log.error('Could not read instance object!');\n        this.terminate('Config migration required', EXIT_CODES.INVALID_ADAPTER_CONFIG);\n        return;\n      }\n\n      const oldNative: ioBroker.AdapterConfigV1 = instanceObj.native as ioBroker.AdapterConfigV1;\n\n      // log a warning to inform the user to re-install the remote clients if remote is enabled\n      if (oldNative.remoteEnabled) {\n        this.log.warn(`Please make sure to re-install you remote clients, or they won't be able to connect!`);\n      }\n\n      const newNative: ioBroker.AdapterConfig = {\n        defaultInterval: oldNative.defaultInterval,\n        remoteEnabled: oldNative.remoteEnabled,\n        remoteKey: oldNative.remoteKey,\n        remotePort: oldNative.remotePort,\n        w1DevicesPath: oldNative.w1DevicesPath,\n        sensors: [],\n      };\n\n      // sort the old sensors by given sortOrder\n      oldNative._values.sort((a, b) => {\n        if (typeof a.sortOrder === 'number' && typeof b.sortOrder === 'number') {\n          return a.sortOrder - b.sortOrder;\n        }\n        return 0;\n      });\n\n      // migrate sensors\n      for (const oldSensor of oldNative._values) {\n        const { obj, sortOrder, ...sensor } = oldSensor;\n        newNative.sensors.push(sensor);\n\n        // TODO: remove native part from the sensor object\n        /*const sensorObj = await this.getForeignObjectAsync(obj._id);\n        if (sensorObj) {\n          sensorObj.native = {};\n          await this.setForeignObjectAsync(obj._id, sensorObj);\n        }*/\n      }\n\n      // delete some objects - they will be recreated on adapter restart\n      await Promise.all([\n        this.delObjectAsync('actions'),\n        this.delObjectAsync('actions.readNow'),\n        this.delObjectAsync('info'),\n        this.delObjectAsync('info.connection'),\n        this.delObjectAsync('sensors'),\n      ]);\n\n      instanceObj.native = newNative;\n      this.log.info('Rewriting adapter config');\n      this.setForeignObjectAsync(`system.adapter.${this.namespace}`, instanceObj);\n      this.terminate('Restart adapter to apply config changes', EXIT_CODES.START_IMMEDIATELY_AFTER_STOP);\n      return;\n    }\n\n    // remote sensor server\n    if (this.config.remoteEnabled) {\n      // check the port\n      if (!this.config.remotePort || this.config.remotePort <= 0) {\n        this.log.warn('Config: Invalid port for the remote sensor server! Using default port 1820.');\n        this.config.remotePort = 1820;\n      }\n\n      // check the key\n      if (typeof this.config.remoteKey !== 'string' || this.config.remoteKey.length !== 64) {\n        this.config.remoteKey = crypto.randomBytes(32).toString('hex');\n        this.log.error(`Config: Invalid key for the remote sensor server! Using random key \"${this.config.remoteKey}\".`);\n      }\n\n      this.remoteSensorServer = new RemoteSensorServer(this.config.remotePort, this.config.remoteKey, this);\n\n      this.remoteSensorServer.on('listening', () => {\n        this.log.info(`Remote sensor server is listening on port ${this.config.remotePort}`);\n        this.updateInfoConnection();\n      });\n\n      this.remoteSensorServer.on('error', (err: Error) => {\n        this.log.warn(`Remote sensor server error: ${err.toString()}`);\n        this.log.debug(`${err.toString()} ${err.stack}`);\n        this.updateInfoConnection();\n      });\n    }\n\n    // setup sensors\n    if (!Array.isArray(this.config.sensors)) {\n      this.config.sensors = [];\n    }\n    for (const sensorCfg of this.config.sensors) {\n      if (!/^[0-9a-f]{2}-[0-9a-f]{12}$/.test(sensorCfg.address)) {\n        this.log.warn(`Invalid sensor address configured: ${sensorCfg.address}`);\n        continue;\n      }\n\n      if (this.sensors[sensorCfg.address]) {\n        this.log.warn(`Sensor ${sensorCfg.address} is configured twice! Ignoring the all expect the first.`);\n        continue;\n      }\n\n      if (sensorCfg.remoteSystemId && !this.config.remoteEnabled) {\n        this.log.warn(`Sensor ${sensorCfg.address} is configured as remote sensor of ${sensorCfg.remoteSystemId} but remote sensors are not enabled!`);\n        continue;\n      }\n\n      // create/update object\n      const name = sensorCfg.name || sensorCfg.address;\n      await this.extendObjectAsync(`sensors.${sensorCfg.address}`, {\n        type: 'state',\n        common: {\n          name: sensorCfg.enabled ? name : i18n.getStringOrTranslated('%s (disabled)', name),\n          type: 'number',\n          role: 'value.temperature',\n          unit: sensorCfg.unit || '\u00B0C',\n          read: true,\n          write: false,\n          def: null,\n          icon: sensorCfg.enabled ? 'ds18b20.png' : 'sensor_disabled.png',\n        },\n        native: {},\n      });\n\n      // stop here if sensor is not enabled\n      if (!sensorCfg.enabled) {\n        this.log.debug(`Sensor ${sensorCfg.address} is not enabled`);\n        continue;\n      }\n\n      // init the sensor\n      let interval: number;\n      if (typeof sensorCfg.interval === 'number') {\n        interval = sensorCfg.interval;\n      } else if (typeof sensorCfg.interval === 'string' && sensorCfg.interval.length > 0) {\n        interval = parseInt(sensorCfg.interval, 10);\n        if (isNaN(interval)) {\n          this.log.warn(`Query interval for sensor ${sensorCfg.address} is invalid! Using default.`);\n          interval = this.config.defaultInterval;\n        }\n      } else {\n        interval = this.config.defaultInterval;\n      }\n      this.sensors[sensorCfg.address] = new Sensor({\n        w1DevicesPath: this.config.w1DevicesPath,\n        address: sensorCfg.address,\n        interval,\n        nullOnError: !!sensorCfg.nullOnError,\n        factor: typeof sensorCfg.factor === 'number' ? sensorCfg.factor : 1,\n        offset: typeof sensorCfg.offset === 'number' ? sensorCfg.offset : 0,\n        decimals: typeof sensorCfg.decimals === 'number' ? sensorCfg.decimals : null,\n        remoteSystemId: typeof sensorCfg.remoteSystemId === 'string' ? sensorCfg.remoteSystemId : null,\n      }, this);\n      this.sensors[sensorCfg.address].on('value', this.handleSensorValue);\n      this.sensors[sensorCfg.address].on('error', this.handleSensorError);\n      this.sensors[sensorCfg.address].on('errorStateChanged', this.handleSensorErrorStateChanged);\n    }\n\n    const count = Object.keys(this.sensors).length;\n    this.log.debug(`Loaded ${count} enabled sensors`);\n\n    if (count === 0) {\n      this.log.warn('No sensors configured or enabled!');\n    }\n\n    // check for sensor objects not configured\n    const objListSensors = await this.getObjectListAsync({\n      startkey: `${this.namespace}.sensors.`,\n      endkey: `${this.namespace}.sensors.\\u9999`,\n    });\n    const reAddress = new RegExp(`^${this.name}\\\\.${this.instance}\\\\.sensors\\\\.(.+)$`);\n    for (const item of objListSensors.rows) {\n      const m = item.id.match(reAddress);\n      if (m) {\n        const addr = m[1];\n        if (!this.config.sensors.find((s) => s.address === addr)) {\n          // not configured\n          this.log.info(`Delete object ${item.id} since sensor is not configured`);\n          await this.delObjectAsync(item.id);\n        }\n      }\n    }\n\n    // subscribe needed states\n    this.subscribeStates('actions.*');\n  }\n\n  /**\n   * Is called when adapter shuts down - callback has to be called under any circumstances!\n   */\n  @boundMethod\n  private async onUnload(callback: () => void): Promise<void> {\n    try {\n      // stop all intervals from the sensors\n      for (const address in this.sensors) {\n        this.sensors[address].stop();\n      }\n\n      // stop the remote sensor server\n      if (this.remoteSensorServer) {\n        await this.remoteSensorServer.stop();\n      }\n\n      // reset connection state\n      if (!this.doingMigration) {\n        await this.setStateAsync('info.connection', false, true);\n      }\n\n    } catch(e) { }\n\n    callback();\n  }\n\n  /**\n   * Handler for incoming sensor values.\n   * @param value The value or null in case of an error.\n   * @param address The Address of the sensor.\n   */\n  @boundMethod\n  private handleSensorValue (value: number | null, address: string): void {\n    if (!this.sensors[address]) return;\n\n    this.log.debug(`Got value ${value} from sensor ${address}`);\n\n    if (value === null) {\n      this.setStateAsync(`sensors.${address}`, {\n        ack: true,\n        val: null,\n        q: 0x81, // general problem by sensor\n      });\n    } else {\n      this.setStateAsync(`sensors.${address}`, {\n        ack: true,\n        val: value,\n      });\n    }\n  }\n\n  /**\n   * Handler for sensor errors.\n   * @param err The error.\n   * @param address The address of the sensor.\n   */\n  @boundMethod\n  private handleSensorError (err: Error, address: string): void {\n    this.log.warn(`Error reading sensor ${address}: ${err}`);\n  }\n\n  /**\n   * Handler for changes of error state of a sensor.\n   * This will change the info.connection state of the adapter to true if all\n   * sensors are ok and false if at least one sensor has an error.\n   * @param hasError Indicator if the sensor has an error or not.\n   * @param address  The address of the sensor.\n   */\n  @boundMethod\n  private handleSensorErrorStateChanged (hasError: boolean, address: string): void {\n    this.log.debug(`Error state of sensor ${address} changed to ${hasError}`);\n\n    this.extendObjectAsync(`sensors.${address}`, {\n      common: {\n        icon: hasError ? 'sensor_error.png' : 'sensor_ok.png',\n      },\n    });\n\n    this.updateInfoConnection();\n  }\n\n  /**\n   * Update the info.connection state depending on the error state of all\n   * sensors and the listening state of the remote sensor server.\n   */\n  private updateInfoConnection (): void {\n    // check if remote sensor server is listening if enabled\n    if (this.remoteSensorServer && !this.remoteSensorServer.isListening()) {\n      // server enabled but not listening\n      this.setStateAsync('info.connection', false, true);\n      return;\n    }\n\n    // are any sensors available?\n    if (Object.keys(this.sensors).length === 0) {\n      // no sensors\n      this.setStateAsync('info.connection', false, true);\n      return;\n    }\n\n    // check all sensors for errors\n    for (const address in this.sensors) {\n      if (this.sensors[address].hasError) {\n        // at least one sensor has an error, set connection state to false\n        this.setStateAsync('info.connection', false, true);\n        return;\n      }\n    }\n\n    // all sensors are ok, set connection state to true\n    this.setStateAsync('info.connection', true, true);\n  }\n\n  /**\n   * Get a defined sensor from it's ioBroker ID or 1-wire address.\n   * @param  idOrAddress The ID or address of the sensor.\n   * @return             The sensor or null.\n   */\n  public getSensor (idOrAddress: string): Sensor | null {\n    if (this.sensors[idOrAddress]) return this.sensors[idOrAddress];\n\n    // check id\n    const m = /^ds18b20\\.\\d+\\.sensors\\.(.+)$/.exec(idOrAddress);\n    if (m && this.sensors[m[1]]) {\n      return this.sensors[m[1]];\n    }\n\n    return null;\n  }\n\n  /**\n   * Trigger the reading of a single sensor or all sensors.\n   * If all sensor should be read, errors on single sensors will be represented by `null` values.\n   * @param idOrAddress The ioBroker ID or 1-wire address of the sensor. Use `all` or an empty string to read all sensors.\n   * @throws Error if a single sensor should be read and an error occurs.\n   */\n  private async readNow (): Promise<Record<string, number | null>>;\n  private async readNow (idOrAddress: undefined): Promise<Record<string, number | null>>;\n  private async readNow (idOrAddress: 'all' | ''): Promise<Record<string, number | null>>;\n  private async readNow (idOrAddress: string): Promise<number | null>;\n  private async readNow (idOrAddress?: string): Promise<Record<string, number | null> | number | null> {\n    if (typeof idOrAddress !== 'string' || idOrAddress === 'all' || idOrAddress === '') {\n      // read all sensors\n      this.log.info(`Read data from all sensors now`);\n      const results: Record<string, number | null> = {};\n      for (const address in this.sensors) {\n        try {\n          results[address] = await this.sensors[address].read();\n        } catch (err) {\n          results[address] = null;\n        }\n      }\n\n      return results;\n\n    } else {\n      // read a specific sensor\n      const sens = this.getSensor(idOrAddress);\n\n      if (!sens) {\n        this.log.warn(`No sensor with address or id ${idOrAddress} found!`);\n        return null;\n      }\n\n      this.log.info(`Read data from sensor ${sens.address} now`);\n      return await sens.read();\n    }\n  }\n\n  /**\n   * Search for local and remote sensors.\n   * @returns Array of the found sensors\n   */\n  private async searchSensors (): Promise<SearchedSensor[]> {\n    const sensors: SearchedSensor[] = [];\n\n    // local sensors\n    try {\n      const files = await readdir(this.config.w1DevicesPath);\n\n      const proms: Promise<string>[] = [];\n      for (const file of files) {\n        if (/^w1_bus_master\\d+$/.test(file)) { // devices path used\n          this.log.debug(`Reading ${this.config.w1DevicesPath}/${file}/w1_master_slaves`);\n          proms.push(readFile(`${this.config.w1DevicesPath}/${file}/w1_master_slaves`, 'utf8'));\n        } else if (file === 'w1_master_slaves') { // path of one w1_bus_masterX used\n          this.log.debug(`Reading ${this.config.w1DevicesPath}/w1_master_slaves`);\n          proms.push(readFile(`${this.config.w1DevicesPath}/w1_master_slaves`, 'utf8'));\n        }\n      }\n\n      const localSensors: SearchedSensor[] = (await Promise.all(proms)).reduce<string[]>((acc, cur) => {\n        acc.push(...cur.trim().split('\\n'));\n        return acc;\n      }, []).map((addr) => ({ address: addr, remoteSystemId: '' }));\n\n      sensors.push(...localSensors);\n\n    } catch (er: any) {\n      this.log.warn(`Error while searching for local sensors: ${er.toString()}`);\n    }\n\n    // remote sensors\n    if (this.config.remoteEnabled && this.remoteSensorServer) {\n      try {\n        const remoteSensors = await this.remoteSensorServer.search();\n        sensors.push(...remoteSensors);\n      } catch (er: any) {\n        this.log.warn(`Error while searching for remote sensors: ${er.toString()}`);\n      }\n    }\n\n    this.log.debug(`Sensors found: ${JSON.stringify(sensors)}`);\n\n    return sensors;\n  }\n\n  /**\n   * Is called if a subscribed state changes.\n   * @param id    The ID of the state.\n   * @param state The ioBroker state.\n   */\n  @boundMethod\n  private async onStateChange(id: string, state: ioBroker.State | null | undefined): Promise<void> {\n    // don't do anything if state is deleted or ack is set\n    if (!state || state.ack) {\n      return;\n    }\n\n    // handle special states\n    if (id === `${this.namespace}.actions.readNow`) {\n      await this.readNow(state.val as string).catch(() => { /* noop */});\n      await this.setStateAsync(this.namespace + '.actions.readNow', '', true);\n    }\n  }\n\n  /**\n   * Some message was sent to this instance over message box (e.g. by a script).\n   * @param obj The received ioBroker message.\n   */\n  @boundMethod\n  private async onMessage(obj: ioBroker.Message): Promise<void> {\n    this.log.debug('Got message ' + JSON.stringify(obj));\n\n    if (typeof obj === 'object') {\n      switch (obj.command) {\n        case 'read':\n        case 'readNow':\n          // we should read sensors now...\n          try {\n            const value = (typeof obj.message === 'string') ? await this.readNow(obj.message) : await this.readNow();\n            if (obj.callback) {\n              this.sendTo(obj.from, obj.command, { err: null, value }, obj.callback);\n            }\n            return;\n          } catch (err: any) {\n            this.log.debug(err.toString());\n            if (obj.callback) {\n              this.sendTo(obj.from, obj.command, { err: err.toString(), value: null }, obj.callback);\n            }\n          }\n          break;\n\n        case 'getRemoteSystems':\n          // get connected remote systems\n          // don't do anything if no callback is provided\n          if (!obj.callback) return;\n\n          if (!this.remoteSensorServer) {\n            this.sendTo(obj.from, obj.command, [], obj.callback);\n            return;\n          }\n          this.sendTo(obj.from, obj.command, this.remoteSensorServer.getConnectedSystems(), obj.callback);\n\n          break;\n\n        case 'getRemoteSystemsAdminUi':\n          // get connected remote systems\n          // don't do anything if no callback is provided\n          if (!obj.callback) return;\n\n          let remotes = this.remoteSensorServer?.getConnectedSystems().join(', ');\n          if (!remotes) {\n            remotes = '---';\n          }\n          this.sendTo(obj.from, obj.command, remotes, obj.callback);\n\n          break;\n\n        case 'search':\n        case 'searchSensors':\n          // search for sensors\n          // don't do anything if no callback is provided\n          if (!obj.callback) return;\n\n          this.sendTo(obj.from, obj.command, { sensors: await this.searchSensors() }, obj.callback);\n\n          break;\n\n        case 'searchSensorsAdminUi':\n          // search for sensors from the admin ui\n          // don't do anything if no callback is provided\n          if (!obj.callback) return;\n\n          const sensors: ioBroker.AdapterConfigSensor[] = [];\n\n          // use sensors currently defined in admin ui\n          if (typeof obj.message === 'object' && Array.isArray(obj.message.sensors)) {\n            sensors.push(...obj.message.sensors);\n          }\n\n          // search for sensors and add found sensors if not already in\n          const foundSensors = await this.searchSensors();\n          for (const foundSensor of foundSensors) {\n            if (sensors.findIndex((cfgSensor) => (cfgSensor.address === foundSensor.address && cfgSensor.remoteSystemId === foundSensor.remoteSystemId)) < 0) {\n              // not in the list... add it\n              sensors.push({\n                address: foundSensor.address,\n                remoteSystemId: foundSensor.remoteSystemId,\n                name: '',\n                interval: null,\n                unit: '\u00B0C',\n                factor: 1,\n                offset: 0,\n                decimals: 2,\n                nullOnError: true,\n                enabled: true,\n              });\n            }\n          }\n\n          // send back the result\n          this.sendTo(obj.from, obj.command, { native: { sensors } }, obj.callback);\n\n          break;\n\n        case 'getNewRemoteKey':\n          // don't do anything if no callback is provided\n          if (!obj.callback) return;\n\n          this.sendTo(obj.from, obj.command, { native: { remoteKey: genHexString(64) } }, obj.callback);\n          break;\n      }\n    }\n  }\n\n}\n\nif (require.main !== module) {\n  // Export the constructor in compact mode\n  module.exports = (options: Partial<AdapterOptions> | undefined) => new Ds18b20Adapter(options);\n} else {\n  // otherwise start the instance directly\n  (() => new Ds18b20Adapter())();\n}\n\n// export the type of the adapter class to use it in other files\nexport type { Ds18b20Adapter };\n"],
  "mappings": "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",
  "names": []
}
