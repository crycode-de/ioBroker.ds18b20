{
  "version": 3,
  "sources": ["../../src/remote/ds18b20-remote-client.ts"],
  "sourcesContent": ["/**\n * ioBroker.ds18b20 remote client\n *\n * Remote client for the ioBroker.ds18b20 adapter.\n * This client has zero dependencies and can be started on any linux os running\n * Node.js.\n *\n * The client will connect to the ioBroker adapter using a TCP socket and\n * provide an interface to let the adapter read 1-wire sensors connected to the\n * client system.\n *\n * MIT License\n *\n * Copyright (c) 2021-2024 Peter M\u00FCller <peter@crycode.de> (https://crycode.de)\n */\n\nimport { promisify } from 'util';\nimport { Socket } from 'net';\nimport fs from 'fs';\nimport os from 'os';\n\nconst readDir = promisify(fs.readdir);\nconst readFile = promisify(fs.readFile);\n\nimport { Logger } from './logger';\n\nimport {\n  decrypt,\n  encrypt,\n  REMOTE_PROTOCOL_VERSION,\n} from './common';\n\n/**\n * Keys to read from a .env file into process.env\n */\nconst ENV_KEYS = [\n  'ADAPTER_HOST',\n  'ADAPTER_KEY',\n  'ADAPTER_PORT',\n  'DEBUG',\n  'SYSTEM_ID',\n  'W1_DEVICES_PATH',\n];\n\n/**\n * Main class for ioBroker.ds18b20 remote client.\n */\nclass Ds18b20Remote {\n\n  /**\n   * Host where the adapter runs on.\n   */\n  private readonly adapterHost: string;\n\n  /**\n   * Port on which the adapter is listening for remote connections.\n   * Default is `1820`.\n   */\n  private readonly adapterPort: number;\n\n  /**\n   * Encryption key used to encrypt/decrypt the communication with the adapter.\n   */\n  private readonly adapterKey: Buffer;\n\n  /**\n   * ID of this remote system.\n   * This should be unique. Defaults to the system hostname.\n   */\n  private readonly systemId: string;\n\n  /**\n   * System path to the 1-wire devices. Default is `/sys/bus/w1/devices`.\n   */\n  private readonly w1DevicesPath: string;\n\n  /**\n   * The socket used to communicate with the adapter.\n   */\n  private socket: Socket;\n\n  /**\n   * Timeout to trigger socket reconnects.\n   */\n  private reconnectTimeout: NodeJS.Timeout | null = null;\n\n  /**\n   * Flag if ds18b20-remote should exit.\n   * If `true` a reconnect won't be possible.\n   */\n  private shouldExit: boolean = false;\n\n  /**\n   * String of the received data.\n   * All received data chunks will be appended to this until we got `\\n`.\n   * On `\\n` data before it will be processed.\n   */\n  private recvData: string = '';\n\n  /**\n   * Our simple logger.\n   */\n  private readonly log: Logger;\n\n  constructor () {\n    // bind methods\n    this.connect = this.connect.bind(this);\n    this.exit = this.exit.bind(this);\n    this.onClose = this.onClose.bind(this);\n    this.onData = this.onData.bind(this);\n    this.onError = this.onError.bind(this);\n    this.onConnect = this.onConnect.bind(this);\n\n    this.log = new Logger();\n    this.log.log('- ioBroker.ds18b20 remote client -');\n\n    // read env vars from a .env file in cwd\n    this.readDotEnv();\n\n    // get the system ID\n    if (process.env.SYSTEM_ID) {\n      this.systemId = process.env.SYSTEM_ID.trim();\n    } else {\n      this.systemId = os.hostname();\n      this.log.warn(`Using the hostname ${this.systemId} as system ID. Please set SYSTEM_ID to a unique value.`);\n    }\n    this.log.debug(`systemId`, this.systemId);\n\n    // get adapter port\n    if (process.env.ADAPTER_PORT) {\n      try {\n        this.adapterPort = parseInt(process.env.ADAPTER_PORT, 10);\n      } catch (err) {\n        this.log.error(`Invalid ADAPTER_PORT!`, err);\n        process.exit(1);\n      }\n    } else {\n      this.adapterPort = 1820;\n    }\n    this.log.debug(`adapterPort`, this.adapterPort);\n\n    // get adapter host\n    this.adapterHost = (process.env.ADAPTER_HOST ?? '').trim();\n    if (this.adapterHost.length <= 0) {\n      this.log.error(`No ADAPTER_HOST given!`);\n      process.exit(1);\n    }\n    this.log.debug(`adapterHost`, this.adapterHost);\n\n    // get the encryption key\n    this.adapterKey = Buffer.from(process.env.ADAPTER_KEY ?? '', 'hex');\n    if (this.adapterKey.length !== 32) {\n      this.log.error(`ADAPTER_KEY is no valid key!`);\n      process.exit(1);\n    }\n    this.log.debug(`adapterKey`, this.adapterKey);\n\n    // get the 1-wire devices path\n    this.w1DevicesPath = process.env.W1_DEVICES_PATH ?? '/sys/bus/w1/devices';\n    if (!fs.existsSync(this.w1DevicesPath)) {\n      this.log.error(`The 1-wire devices path ${this.w1DevicesPath} does not exist!`);\n      process.exit(1);\n    }\n    this.log.debug(`w1DevicesPath`, this.w1DevicesPath);\n\n    // register signal handlers for exit\n    process.on('SIGINT', this.exit);\n    process.on('SIGTERM', this.exit);\n\n    // create the socket\n    this.socket = new Socket();\n\n    this.socket.on('close', this.onClose);\n    this.socket.on('data', this.onData);\n    this.socket.on('error', this.onError);\n    this.socket.on('connect', this.onConnect);\n\n    // try to connect\n    this.connect();\n  }\n\n  /**\n   * Try to connect to the adapter.\n   */\n  private connect (): void {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n\n    // don't connect if we should exit\n    if (this.shouldExit) {\n      return;\n    }\n\n    this.log.info(`Connecting to ${this.adapterHost}:${this.adapterPort} ...`);\n\n    this.socket.connect({\n      host: this.adapterHost,\n      port: this.adapterPort,\n    });\n  }\n\n  /**\n   * Handle established connection.\n   */\n  private onConnect (): void {\n    this.log.info(`Connected with adapter`);\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n    }\n    this.reconnectTimeout = null;\n  }\n\n  /**\n   * Handle incoming data chunks.\n   * @param data A data chunk.\n   */\n  private onData (data: Buffer): void {\n    this.recvData += data.toString();\n\n    // check for `\\n` and process the data; recvData may contain multiple `\\n`!\n    let idx = this.recvData.indexOf('\\n');\n    while (idx > 0) {\n      const raw = this.recvData.slice(0, idx);\n      this.recvData = this.recvData.slice(idx + 1);\n      void this.handleSocketData(raw);\n      idx = this.recvData.indexOf('\\n');\n    }\n  }\n\n  /**\n   * Handle a message from the adapter.\n   * @param raw The raw (encoded) message from the adapter.\n   */\n  private async handleSocketData (raw: string): Promise<void> {\n    // try to decrypt and parse the data\n    let data: RemoteData;\n    try {\n      const dataStr = decrypt(raw, this.adapterKey);\n      data = JSON.parse(dataStr) as RemoteData;\n    } catch (err) {\n      this.log.warn(`Decrypt of data failed! ${err}`);\n      // close the socket\n      this.socket.end();\n      return;\n    }\n\n    this.log.debug('message from adapter:', data);\n\n    switch (data.cmd) {\n      case 'clientInfo':\n        // get client info\n        if (data.protocolVersion !== REMOTE_PROTOCOL_VERSION) {\n          this.log.warn(`Protocol version ${data.protocolVersion} from the adapter does not match the remote client protocol version ${REMOTE_PROTOCOL_VERSION}! Please reinstall the remote client.`);\n        }\n\n        this.log.info('Sending client info to the adapter');\n        await this.send({\n          cmd: 'clientInfo',\n          protocolVersion: REMOTE_PROTOCOL_VERSION,\n          systemId: this.systemId,\n        });\n        break;\n\n      case 'read': {\n        // read sensor data\n        if (!data.address) {\n          this.log.warn(`Got read command without address from adapter!`);\n          return;\n        }\n\n        let raw2: string;\n        try {\n          raw2 = await readFile(`${this.w1DevicesPath}/${data.address}/w1_slave`, 'utf8');\n          this.log.debug(`Read from file ${this.w1DevicesPath}/${data.address}/w1_slave:`, raw);\n        } catch (err) {\n          this.log.warn(`Read from file ${this.w1DevicesPath}/${data.address}/w1_slave failed! ${err}`);\n          this.log.debug(err);\n          raw2 = '';\n        }\n\n        await this.send({\n          cmd: 'read',\n          address: data.address,\n          ts: data.ts,\n          raw: raw2,\n        });\n        break;\n      }\n\n      case 'search':\n        // search for sensors\n        try {\n          const files = await readDir(this.w1DevicesPath);\n\n          const proms: Promise<string>[] = [];\n          for (const file of files) {\n            if (/^w1_bus_master\\d+$/.exec(file)) { // devices path used\n              this.log.debug(`reading ${this.w1DevicesPath}/${file}/w1_master_slaves`);\n              proms.push(readFile(`${this.w1DevicesPath}/${file}/w1_master_slaves`, 'utf8'));\n            } else if (file === 'w1_master_slaves') { // path of one w1_bus_masterX used\n              this.log.debug(`reading ${this.w1DevicesPath}/w1_master_slaves`);\n              proms.push(readFile(`${this.w1DevicesPath}/w1_master_slaves`, 'utf8'));\n            }\n          }\n\n          const addresses: string[] = (await Promise.all(proms)).reduce<string[]>((acc, cur) => {\n            acc.push(...cur.trim().split('\\n'));\n            return acc;\n          }, []);\n\n          await this.send({\n            cmd: 'search',\n            ts: data.ts,\n            systemId: data.systemId,\n            addresses,\n          });\n\n        } catch (err) {\n          this.log.warn(`Searching for sensors failed! ${err}`);\n          this.log.debug(err);\n        }\n\n        break;\n\n      default:\n        this.log.warn(`Unknown command from adapter`);\n    }\n  }\n\n  /**\n   * Handler for socket errors.\n   * Each error will trigger a socket disconnect and reconnect.\n   * @param err The error.\n   */\n  private onError (err: Error): void {\n    this.log.warn(`Socket error:`, err.toString());\n    this.log.debug(err);\n\n    // close the socket on an error\n    this.socket.end();\n\n    this.reconnect();\n  }\n\n  /**\n   * Handler for socket close events.\n   */\n  private onClose (): void {\n    this.log.info('Socket closed');\n    this.reconnect();\n  }\n\n  /**\n   * Init a reconnect after 30 seconds.\n   */\n  private reconnect (): void {\n    if (!this.reconnectTimeout && !this.shouldExit) {\n      // schedule reconnect\n      this.log.info(`Reconnect in 30 seconds`);\n      this.reconnectTimeout = setTimeout(this.connect, 30000);\n    }\n  }\n\n  /**\n   * Send some data to the adapter.\n   * The data will be stringified and encrypted before sending.\n   * @param data The data object to send.\n   */\n  private async send (data: RemoteData): Promise<void> {\n    this.log.debug('send to adapter:', data);\n    return await new Promise<void>((resolve, reject) => {\n      this.socket.write(encrypt(JSON.stringify(data), this.adapterKey) + '\\n', (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  /**\n   * Read env vars from a .env file in the current working dir if exists.\n   */\n  private readDotEnv (): void {\n    if (!fs.existsSync('.env')) return;\n\n    let data: string[];\n    try {\n      data = fs.readFileSync('.env', 'utf-8').split('\\n').map((l) => l.trim());\n    } catch (err) {\n      this.log.debug('can\\'t read .env file', err);\n      return;\n    }\n\n    for (const line of data) {\n      if (!line || line.startsWith('#')) continue;\n\n      const idx = line.indexOf('=');\n      if (idx <= 0) continue;\n\n      const key = line.slice(0, idx).trim();\n      const val = line.slice(idx + 1).trim().replace(/(^\"|\"$)/g, '');\n\n      if (ENV_KEYS.includes(key)) {\n        // ignore if this env is already set\n        if (process.env[key]) continue;\n\n        // set this env\n        process.env[key] = val;\n        this.log.debug(`read ${key}=${val} from .env file`);\n      }\n    }\n  }\n\n  /**\n   * Handler process exit.\n   * This will stop all timeouts and close the socket connection.\n   */\n  private exit (): void {\n    this.shouldExit = true;\n\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n    }\n\n    this.socket.end();\n  }\n}\n\n// create an instance of the main class for startup\nnew Ds18b20Remote();\n"],
  "mappings": "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",
  "names": ["fs", "os"]
}
